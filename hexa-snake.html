<script>
const HexaSnake = subclass => class extends subclass {
    static get config() {
        return {
            properties: {
                grid: {
                    type: Array,
                    value: null,
                },
                snake: {
                    type: Array,
                    value: [{
                        direction: 0,
                        row:1,
                        col:2,
                        color: 'red'
                    }]
                },
                direction: {
                    type: Number,
                    value: 0
                },
                state: {
                    type: String,
                    value: "init"
                }
            },
            observers: [ 'stateChanged(state)' ]
        }
    }

    connectedCallback() {
        super.connectedCallback();

        // todo: snakey functionality (movement, eating, etc.)
        this.state="running";  // should be init...
    }

    disconnectedCallback() {
        super.disconnectedCallback();
    }

    generateGrid(sideLength) {
        // faster with a rectangular grid mapped to triangles
        this._num_cols = 4*sideLength-1;
        this._num_rows = 2*sideLength;
        // make a max_cols,max_rows
        this.grid = Array(this._num_rows).fill().map(() => Array(this._num_cols).fill());

        for(let row=0;row<this._num_rows;row++) {
            for(let col=0;col<this._num_cols;col++) {
                this.grid[row][col] = {
                    color: ['#8f8','#3d3','#6e6'][Math.floor(3*Math.random())]
                };
            }
        }

        // make "portals" (on the open sides of the hexagon)
        // make a border
        // make obstacles
        // make bg
    }

    changeDirection(direction) {
        // going in the same direction and directly 180 degree turn not valid
        if(this.direction !== direction && Math.abs(this.direction-direction)!=180) {
            this.direction = direction;
        }
    }

    move(extend) {
        // send events out on fruit eaten, wall/own hit, etc. 
        const newHead = this.getNewHead();

        // do stuff
        //console.log(newHead);
        // check for collision
 
        if(this.grid[newHead.row][newHead.col].snake) {
            this.dispatchEvent(new CustomEvent('snake-collision'), {hit: 'self'}); // need to make walls, etc.
            this.state = "gameover";
            return;
        }

        this.grid[newHead.row][newHead.col].snake = newHead;

        this.unshift('snake',newHead);
        if(!extend) {
            let tail = this.snake.slice(-1)[0];
            this.grid[tail.row][tail.col].snake = null;
            this.pop('snake');
        }
    }

    getNewHead() {
        // use the position, directon [0,60,120,180,240,300] + knowledge about the grid to move, be blocked, follow portal, etc.
        // TODO: handle sharp corners correctly...
        let row = this.snake[0].row;
        let col = this.snake[0].col;
        switch(this.direction) {
            case 0:
                col = (col+1)%this._num_cols;
                break;
            case 60:
                if((row+col+1)&1) row = (row+this._num_rows-1)%this._num_rows;
                else col = (col+1)%this._num_cols;
                break;
            case 120:
                if((row+col+1)&1) row = (row+this._num_rows-1)%this._num_rows;
                else col = (col+this._num_cols-1)%this._num_cols;
                break;
            case 180:
                col = (col+this._num_cols-1)%this._num_cols;
                break;
            case 240:
                if((row+col)&1) row = (row+1)%this._num_rows;
                else col = (col+this._num_cols-1)%this._num_cols;
                break;
            case 300:
                if((row+col)&1) row = (row+1)%this._num_rows;
                else col = (col+1)%this._num_cols;
                break;
            default:
                console.log(`Unknown direction: ${this.direction}`);
        }

        return {row:row,col:col};
    }
}
</script>
