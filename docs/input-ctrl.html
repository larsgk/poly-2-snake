<html><head><script>
const InputCtrl = (_ => {
  const _InputCtrl = subclass => class extends subclass {
    static get config() {
      return {
        properties: {
          data: {
            type: Object,
            value: _InputCtrl["data"],
          }
        },
        observers: [ 'dataChanged(data)' ]
      }
    }

    dataChanged(data) {
      console.log("InputCtrl data: ", this.data);
      _InputCtrl.notifyPath('data');
    }

    connectedCallback() {
      super.connectedCallback();
      _InputCtrl["instances"].push(this);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      const i = InputCtrl["instances"].indexOf(this);
      if (i >= 0) {
          InputCtrl["instances"].splice(i, 1);
      }
    }
  };

  Object.defineProperty(_InputCtrl, "data", {
    value: {
      touch: {
        delta: {
          x:0,
          y:0
        }
      }
    },
    writable: false,
    enumerable: false,
    configurable: false
  });
  Object.defineProperty(_InputCtrl, "instances", {
    value: [],
    writable: false,
    enumerable: false,
    configurable: false
  });

  _InputCtrl.notifyPath = function(path) {
    _InputCtrl["instances"].forEach(instance => instance.notifyPath(path))
  }

  _InputCtrl.dispatchEvent = function(evt,data) {
    // TODO: investigate if it's ok to reuse - or a new event should be made for each
    _InputCtrl["instances"].forEach(instance => instance.dispatchEvent(evt,data));
  }

  // keyboard handler
  const _KEY_DIR = {
    "KeyD":   0,
    "KeyE":  60,
    "KeyW": 120,
    "KeyA": 180,
    "KeyZ": 240,
    "KeyX": 300 
  };

  const _DIST_THRESHOLD_SQ = 40*40;  // TODO: should be dependent on ppi/resolution - e.g. min "1.5 tiles"

  document.addEventListener('keydown', evt => {
    if(!evt.repeat) {
      console.log('down', evt);
      const dir = _KEY_DIR[evt.code];
      if(dir !== undefined) {
        _InputCtrl.dispatchEvent(new CustomEvent('input-direction', {detail: {value: dir}}));

      } else if(evt.code === 'KeyP') {
        _InputCtrl.dispatchEvent(new CustomEvent('input-toggle-pause', {}));
      }
    }
  });
  document.addEventListener('keyup', evt => {
    console.log('up', evt);
  });

  // touch (swipe gesture) handler
  document.addEventListener('touchstart', evt => {
    //console.log("touchstart", evt);
    _InputCtrl.data.touch.delta = {x:0,y:0};
    _InputCtrl.data.touch.origin = {
      x:evt.touches[0].clientX,
      y:evt.touches[0].clientY
    };
    _InputCtrl.notifyPath('data.touch');
  });

  document.addEventListener('touchmove', evt => {
    //console.log("touchmove", evt);
    if(!_InputCtrl.data.touch.origin)
      return;

    let delta = {
      x:evt.touches[0].clientX-_InputCtrl.data.touch.origin.x,
      y:evt.touches[0].clientY-_InputCtrl.data.touch.origin.y
    };

    if( _DIST_THRESHOLD_SQ <  (delta.x*delta.x + delta.y*delta.y)){
      // find input direction
      let angleQuant = 60 * Math.round(Math.atan2(-delta.y, delta.x) * 3 / Math.PI);
      if(Object.is(angleQuant,-0))angleQuant=0;
      if(angleQuant<0)angleQuant+=360;

      // reset origin to new pos
      _InputCtrl.data.touch.delta = {x:0,y:0};
      _InputCtrl.data.touch.origin.x += delta.x;
      _InputCtrl.data.touch.origin.y += delta.y;
      _InputCtrl.notifyPath('data.touch');

      // emit direction
      console.log("angle",angleQuant);
      _InputCtrl.dispatchEvent(new CustomEvent('input-direction', {detail: {value: angleQuant}}));
    } else {
      _InputCtrl.data.touch.delta = delta;
      _InputCtrl.notifyPath('data.touch.delta');
    }
  });

  document.addEventListener('touchend', evt => {
    //console.log("touchstart", evt);
    _InputCtrl.data.touch.delta = {x:0,y:0};
    _InputCtrl.data.touch.origin = null;
    _InputCtrl.notifyPath('data.touch');
  });

  return _InputCtrl;
})();

</script></head><body></body></html>